# -*- coding: utf-8 -*-
"""BeyondEarth_QuadParadox_DataWatt2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eKKOVxXbImevsVZ5_BjKci-AD1BvPuOm

#**Time Series Analysis**

Data set used :
<br>
https://www.kaggle.com/datasets/henriupton/electricity-dayahead-prices-entsoe
<br>
<hr>
<br>
<p>The dataset used provides hourly day ahead electricity prices for France and interconnections, sourced from the ENTSO-E Transparency Platform.</p>
<p>Electricity day ahead prices refer to the prices at which electricity is bought and sold in the wholesale market for delivery the next day. These prices are determined through a process called day-ahead market (DAM) auctions, where electricity generators and suppliers submit bids and offers for the electricity they are willing to buy or sell for delivery the following day.</p>
"""

import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.seasonal import seasonal_decompose

# Assuming you have a time series dataset with a datetime index
# If not, you can convert your dataset to have a datetime index

# Read your time series data
# Replace 'your_dataset.csv' with your actual dataset file
df = pd.read_csv('electricity_dah_prices[1].csv')

df

# Combine 'date' and 'hour' columns into a single datetime column
df['datetime'] = pd.to_datetime(df['date'] + ' ' + df['hour'].str.split(' - ', expand=True)[0])
df.set_index('datetime', inplace=True)

df.dropna(inplace=True)

# Assuming you have columns for different countries like 'france', 'italy', etc.
# Replace 'france', 'italy', etc. with your actual column names
countries = ['france', 'italy', 'belgium', 'spain', 'uk', 'germany']

# Specify the period for seasonality (assuming daily seasonality with 24 hours per day)
seasonal_period = 24

# Perform time series decomposition for each country
plt.figure(figsize=(15, 12))

for country in countries:
    ts = df[country]

    # Perform time series decomposition with a specified period
    result = seasonal_decompose(ts, model='additive', period=seasonal_period)

    # Plot the original time series, trend, seasonality, and residuals for each country
    plt.subplot(len(countries)+1, 1, countries.index(country)+1)
    plt.plot(ts, label=f'Original Time Series - {country}')
    plt.plot(result.trend, label=f'Trend - {country}')
    plt.plot(result.seasonal, label=f'Seasonality - {country}')
    plt.plot(result.resid, label=f'Residuals - {country}')

    # Move the legend to the right of the plot
    plt.legend(loc='center left', bbox_to_anchor=(1, 0.5))

# Adjust layout and show the plots
plt.tight_layout()
plt.show()

# Keep every 25th row
df_downsampled = df[::25]
df_downsampled

# Assuming you have columns for different countries like 'france', 'italy', etc.
# Replace 'france', 'italy', etc. with your actual column names
country = 'france'

# Specify the period for hourly seasonality (24 hours)
seasonal_period = 24

# Plot the original time series
plt.figure(figsize=(12, 6))
plt.plot(df_downsampled[country], label=f'Original Time Series - {country}')
plt.title(f'Original Time Series - {country}')
plt.legend()
plt.show()

from pmdarima import auto_arima
# Use auto_arima to automatically select the best ARIMA model
# Adjust the seasonal parameter based on your data characteristics
#arima_model = auto_arima(df[country], seasonal=True, m=seasonal_period, trace=True, suppress_warnings=True)
arima_model = auto_arima(df_downsampled[country], seasonal=True, m=seasonal_period, trace=True, suppress_warnings=True, n_jobs=1)

# Print the summary of the best ARIMA model
print(arima_model.summary())

# Plot the fitted values
plt.figure(figsize=(12, 6))
plt.plot(df[country], label=f'Original Time Series - {country}')
plt.plot(arima_model.predict_in_sample(), label='Fitted Values')
plt.title(f'ARIMA Model Fitting - {country}')
plt.legend()
plt.show()

# Forecast future values
forecast_steps = 24  # adjust as needed
forecast = arima_model.predict(n_periods=forecast_steps)
forecast_index = pd.date_range(start=df.index[-1] + pd.Timedelta(hours=1), periods=forecast_steps, freq='H')
plt.figure(figsize=(12, 6))
plt.plot(df[country], label=f'Original Time Series - {country}')
plt.plot(arima_model.predict_in_sample(), label='Fitted Values')
plt.plot(forecast_index, forecast, label='Forecasted Values', linestyle='--', color='red')
plt.title(f'ARIMA Model Forecasting - {country}')
plt.legend()
plt.show()